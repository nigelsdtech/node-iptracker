'use strict'

import {promises as fsPromises} from 'fs'
import {createStubStoreFile, stubExtIpService, stubIntIpService} from './utils/IPService'
import {createGDriveFolder, getGDriveFile, getGDriveFolderId, trashGDriveFolder, GDriveModel} from './utils/GDrive'
import {writeFile} from 'jsonfile'
import {getIPStoreFile} from './utils/misc'
import {promisify} from 'util'
//import GDriveModel from 'gdrive-model'

const {unlink: deleteFile} = fsPromises

const
  cfg          = require('config'),
  chai         = require('chai'),
  Q            = require('q'),
  rewire       = require('rewire'),
  sinon        = require('sinon'),
  ipTracker    = rewire('../../lib/iptracker.js'),
  EmailNotification = require('email-notification')

/*
 * Set up chai
 */
chai.should();

/*
 * Some utility functions
 */



/**
 * cleanup
 * @desc Clean up various things after running a test suite (e.g. store file, email, etc)
 *
 * @param {object}  params
 * @param {boolean} params.ipStoreFile - clean up the ipStoreFile
 */
async function doCleanup ({
  ipStoreFile = false,
  gdriveFolderId = false,
  gdrive = null
}:{
  ipStoreFile: false | string,
  gdriveFolderId: false | string,
  gdrive: null | GDriveModel
}): Promise<void> {

  await Promise.all([
    (ipStoreFile)?    deleteFile(ipStoreFile) : null,
    (gdriveFolderId)? trashGDriveFolder({folderId: gdriveFolderId, gdrive: gdrive}) : null
  ])
  .catch((err) => {
    if (err.code != "ENOENT") console.error(err);
  })

}



const recipientGdrive = new GDriveModel({
  googleScopes        : cfg.drive.scopes,
  clientSecretFile    : cfg.auth.clientSecretFile,
  tokenDir            : cfg.auth.tokenFileDir,
  tokenFile           : cfg.auth.tokenFile,
  userId              : "me"
});


const enConfig = {
  gmailSearchCriteria: `is:inbox is:unread from:${cfg.reporter.emailsFrom} subject:"%SUBJECT%"`,
  format: 'minimal',
  gmail: {
    clientSecretFile : cfg.auth.clientSecretFile,
    googleScopes     : cfg.auth.googleScopes,
    name             : 'Notification finder',
    tokenDir         : cfg.auth.tokenFileDir,
    tokenFile        : cfg.auth.tokenFile,
    userId : 'me'
  },
  maxResults: 1,
  retFields: 'id',
  metadataHeaders: [],
  processedLabelName: null,
  processedLabelId: null,
}

const enNotification = new EmailNotification(
  Object.assign({}, enConfig, {
    gmailSearchCriteria: enConfig.gmailSearchCriteria.replace('%SUBJECT%', `${cfg.appName} Report`)
  })
);
const notificationHasBeenReceived = promisify(enNotification.hasBeenReceived)

const enError = new EmailNotification(
  Object.assign( {}, enConfig, {
    gmailSearchCriteria: enConfig.gmailSearchCriteria.replace('%SUBJECT%', `${cfg.appName} ERROR`)
  })
);
const errorHasBeenReceived = promisify(enError.hasBeenReceived)





const
  timeout = cfg.testTimeout,
  genericIntIPOld = '111.111.111.111',
  genericIntIPNew = '111.111.111.222',
  genericExtIPOld = '222.222.222.111',
  genericExtIPNew = '222.222.222.222'


type buildTestArgs = {
  description: string,
  only: boolean,
  ipStoreContents: {
    atStart: {
      exists: boolean
      contents: Object
    },
    atEnd: {
      exists: boolean
      expectedContents: Object
    }
  },
  notificationEmail: {
    isExpected: boolean
  },
  errorNotificationEmail: {
    isExpected: boolean
  }
  gdriveFile: {
    isExpected: boolean
  }
}


function buildTest (params: buildTestArgs): void {

  const {only, description} = params;
  const describeFn = (only)? describe.only : describe;

  describeFn(description, () => {

    const outcomeStates = {
      driveFile: null,
      ipStoreFileContentsAtEnd: null,
      hasNotificationBeenReceived: null,
      hasErrorNoticeBeenReceived: null
    }


    before(async()=> {

      const {exists, contents} = params.ipStoreContents.atStart
      if (exists) {
        await writeFile(cfg.ipStoreFile, contents)
      }

      const ret = await Promise.all([
        ipTracker(),
        getGDriveFolderId({folderName: cfg.drive.folderName, gdrive: recipientGdrive})
      ])

      const parentFolderId: string = ret[1]
      

      const [driveFile, ipStoreFileContentsAtEnd, hasNotificationBeenReceived, hasErrorNoticeBeenReceived] = await Promise.all([
        
        // driveFile
        getGDriveFile({
          parentFolderId:parentFolderId,
          gdrive:recipientGdrive,
          fileName:cfg.drive.templateFile
        }),

        // ipStoreFileContentsAtEnd
        getIPStoreFile(cfg.ipStoreFile),

        // hasNotificationBeenReceived
        notificationHasBeenReceived(),

        // hasErrorNoticeBeenReceived
        errorHasBeenReceived()
      ])

      outcomeStates.driveFile = driveFile
      outcomeStates.ipStoreFileContentsAtEnd = ipStoreFileContentsAtEnd
      outcomeStates.hasErrorNoticeBeenReceived = hasNotificationBeenReceived
      outcomeStates.hasErrorNoticeBeenReceived = hasErrorNoticeBeenReceived

    })

    const notificationEmailTitle =
      (params.notificationEmail.isExpected)? "Sends an notification email" : "Doesn't send a notification email";

    it(notificationEmailTitle, ()=> {
      outcomeStates.hasNotificationBeenReceived.should.eql(params.notificationEmail.isExpected)
    })


    const errorEmailTitle = (params.errorNotificationEmail.isExpected)? "Sends an error email" : "Doesn't send an error email";

    it(errorEmailTitle, ()=> {
      outcomeStates.hasErrorNoticeBeenReceived.should.eql(params.errorNotificationEmail.isExpected)
    })


    if (params.gdriveFile.isExpected) {
      it("Uploads a file to gdrive", () => {
        outcomeStates.driveFile.size.should.not.eql(null)
      })
    } else {
      it("Doesn't upload a file to gdrive", () => {
        outcomeStates.driveFile.should.eql(null)
      })
    }
    
    if (params.ipStoreContents.atEnd.exists) {
      it("Saves the new details to the IP Store file", () => {
        outcomeStates.ipStoreFileContentsAtEnd.should.eql(params.ipStoreContents.atEnd.expectedContents)
      })
    } else {
      it("IP Store file doesn't exist at the end", () => {
        outcomeStates.ipStoreFileContentsAtEnd.should.eql('ENOENT')
      })
    }

    after (async() => {

      const {exists: existsAtStart} = params.ipStoreContents.atStart
      const {exists: existsAtEnd} = params.ipStoreContents.atEnd
  
      await doCleanup({
        ipStoreFile: (existsAtStart || existsAtEnd)? cfg.ipStoreFile : false,
        gdriveFolderId: (params.gdriveFile.isExpected)? 123 : false,
        gdrive: recipientGdrive
      })
    })

  })
}




/*
 * The tests
 */

var testCases: iTestCase[] = [
  { describe: "Running the script when only the external IP has changed",
  it: "leaves the last_ip file with the latest known IPs",
  oldIPStoreContents: {external:genericOldExtIP,  internal: serviceStubIntIP},
  newIPStoreContents: {external:serviceStubExtIP, internal: serviceStubIntIP}},

  { describe: "Running the script when only the internal IP has changed",
  it: "leaves the last_ip file with the latest known IPs",
  oldIPStoreContents: {external:serviceStubExtIP, internal: genericOldIntIP},
  newIPStoreContents: {external:serviceStubExtIP, internal: serviceStubIntIP}},

  { describe: "Running the script when both the external and internal IPs have changed",
  it: "leaves the last_ip file with the latest known IPs",
  oldIPStoreContents: {external:genericOldExtIP,  internal: genericOldIntIP},
  newIPStoreContents: {external:serviceStubExtIP, internal: serviceStubIntIP}},

  { describe: "Running the script when no ips have changed",
  it: "leaves the last_ip file with the latest known ips",
  oldIPStoreContents: {external:serviceStubExtIP, internal: serviceStubIntIP},
  newIPStoreContents: {external:serviceStubExtIP, internal: serviceStubIntIP},
  storeFileExistsAtStartOverrides: {
    yes : { isCompletionNoticeExpected: false }}},


  { describe: "Running the script when the external IP service returns a bad response",
  it: "does not update the last_ip file",
  extIpServiceStub: {
    response: {
      body: "Service Unavailable",
      statusCode: 500 }},
  oldIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  newIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  isCompletionNoticeExpected: false,
  isErrorNoticeExpected: true,
  storeFileExistsAtStartOverrides: {
    no : {
      checkIPStoreOnCompletion: false,
      IPStoreExistsOnCompletion: false }}},

  { describe: "Running the script when the external IP service request fails",
  it: "does not update the last_ip file",
  extIpServiceStub: {
    replyWithError: "simulated failure" },
  oldIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  newIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  isCompletionNoticeExpected: false,
  isErrorNoticeExpected: true,
  storeFileExistsAtStartOverrides: {
    no : {
      checkIPStoreOnCompletion: false,
      IPStoreExistsOnCompletion: false }}},

  { describe: "Running the script when the internal IP service fails",
  it: "does not update the last_ip file",
  intIpServiceStub: {
    replyWithError: "simulated failure" },
  oldIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  newIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  isCompletionNoticeExpected: false,
  isErrorNoticeExpected: true,
  storeFileExistsAtStartOverrides: {
    no : {
      checkIPStoreOnCompletion: false,
      IPStoreExistsOnCompletion: false }}},

  { describe: "Running the script when the internal IP service doesn't return eth0",
  it: "does not update the last_ip file",
  intIpServiceStub: {
    response: { malformed_response: [] } },
  oldIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  newIPStoreContents: {external:genericOldExtIP, internal: genericOldIntIP},
  isCompletionNoticeExpected: false,
  isErrorNoticeExpected: true,
  storeFileExistsAtStartOverrides: {
    no : {
      checkIPStoreOnCompletion: false,
      IPStoreExistsOnCompletion: false }}}


]



testCases.forEach( (el: iTestCase) => {

  /*
   * Start with the main test case
   */

  var describeFn = (el.only)? describe.only : describe;


  describeFn(el.describe, function () {

    var storeFileExistsAtStartStates = el.storeFileExistsAtStartStates || [ true, false ]

    /*
     * Deviate based on whether a last_ip file existed when the script started
     */
    storeFileExistsAtStartStates.forEach( (isStoreFilePresentAtStart) => {


      /*
       * Set up tests specific to this case
       */
      var isCompletionNoticeExpected      = (el.hasOwnProperty('isCompletionNoticeExpected'))?       el.isCompletionNoticeExpected       : true
      var isErrorNoticeExpected           = (el.hasOwnProperty('isErrorNoticeExpected'))?            el.isErrorNoticeExpected            : false
      var checkIPStoreOnCompletion        = (el.hasOwnProperty('checkIPStoreOnCompletion'))?         el.checkIPStoreOnCompletion         : false
      var IPStoreExistsOnCompletion       = (el.hasOwnProperty('IPStoreExistsOnCompletion'))?        el.IPStoreExistsOnCompletion        : true
      var storeFileExistsAtStartOverrides = (el.hasOwnProperty('storeFileExistsAtStartOverrides'))?  el.storeFileExistsAtStartOverrides  : { yes:{}, no: {} }

      storeFileExistsAtStartOverrides.yes = (storeFileExistsAtStartOverrides.hasOwnProperty('yes'))? storeFileExistsAtStartOverrides.yes : {}
      storeFileExistsAtStartOverrides.no  = (storeFileExistsAtStartOverrides.hasOwnProperty('no'))?  storeFileExistsAtStartOverrides.no  : {}



      if (isStoreFilePresentAtStart) {
        isCompletionNoticeExpected  = (storeFileExistsAtStartOverrides.yes.hasOwnProperty('isCompletionNoticeExpected'))? storeFileExistsAtStartOverrides.yes.isCompletionNoticeExpected : isCompletionNoticeExpected
        isErrorNoticeExpected       = (storeFileExistsAtStartOverrides.yes.hasOwnProperty('isErrorNoticeExpected'))?      storeFileExistsAtStartOverrides.yes.isErrorNoticeExpected      : isErrorNoticeExpected
        checkIPStoreOnCompletion    = (storeFileExistsAtStartOverrides.yes.hasOwnProperty('checkIPStoreOnCompletion'))?   storeFileExistsAtStartOverrides.yes.checkIPStoreOnCompletion   : checkIPStoreOnCompletion
      } else {
        isCompletionNoticeExpected  = (storeFileExistsAtStartOverrides.no.hasOwnProperty('isCompletionNoticeExpected'))?  storeFileExistsAtStartOverrides.no.isCompletionNoticeExpected  : isCompletionNoticeExpected
        isErrorNoticeExpected       = (storeFileExistsAtStartOverrides.no.hasOwnProperty('isErrorNoticeExpected'))?       storeFileExistsAtStartOverrides.no.isErrorNoticeExpected       : isErrorNoticeExpected
        checkIPStoreOnCompletion    = (storeFileExistsAtStartOverrides.no.hasOwnProperty('checkIPStoreOnCompletion'))?    storeFileExistsAtStartOverrides.no.checkIPStoreOnCompletion    : checkIPStoreOnCompletion
        IPStoreExistsOnCompletion   = (storeFileExistsAtStartOverrides.no.hasOwnProperty('IPStoreExistsOnCompletion'))?   storeFileExistsAtStartOverrides.no.IPStoreExistsOnCompletion   : IPStoreExistsOnCompletion
      }


      var description = "last_ip store file "
      description    += (isStoreFilePresentAtStart)? "exists": "doesn't exist"
      description    += " at startup"



      /*
       * Here's the sub test based on the last_ip file
       */
      describe(description, function () {

        this.timeout(timeout)


        var completionNoticeSpy = null
        var errorNoticeSpy      = null
        var restore             = null
        var gdriveFolderId      = null

        before( function(done) {

          completionNoticeSpy = sinon.spy();
          errorNoticeSpy      = sinon.spy();

          var extIPServiceStub = stubExtIpService( (el.hasOwnProperty('extIpServiceStub'))? el.extIpServiceStub : null)
          var intIPServiceStub = stubIntIpService( (el.hasOwnProperty('intIpServiceStub'))? el.intIpServiceStub : null)

          restore = ipTracker.__set__('reporter', {
            configure: function () {},
            handleError: errorNoticeSpy,
            sendCompletionNotice: completionNoticeSpy
          })


          var completionJobs = [
            Q.nfcall(createTestGDriveFolder, null)
	  ]

          if (isStoreFilePresentAtStart) {
            completionJobs.push(Q.nfcall(createStubStoreFile,el.oldIPStoreContents))
          }

          Q.all(completionJobs)
          .spread (function (gdriveFolder) {

            gdriveFolderId = gdriveFolder.id
            return Q.nfcall(ipTracker,null)
	  })
          .done(function () {
            done()
          });


        })

        after( function (done) {
          restore()
          doCleanup({
            gdriveFolderId: gdriveFolderId
          },done)
        })


        /*
	 * Test for the final value of the ip store file
	 */

        if (checkIPStoreOnCompletion) {
          it(el.it, function(done) {
            jsonFile.readFile(cfg.ipStoreFile, function(err, newIPStoreContents) {
              if (err) throw new Error ('Error loading last_ip file: ' + err)
              newIPStoreContents.external.should.equal(el.newIPStoreContents.external)
              newIPStoreContents.internal.should.equal(el.newIPStoreContents.internal)
              done()
            })
          })
        }


        /*
	 * Test the existence of the IP store on completion
	 */

        if (!IPStoreExistsOnCompletion) {
          it("last_ip store file doesn't exist on completion", function(done) {
            jsonFile.readFile(cfg.ipStoreFile, function(err, newIPStoreContents) {
              err.code.should.equal('ENOENT')
              done()
            })
          })
        }

        /*
         * Test for a completion notice (by email and in gdrive)
         */

        var completionNoticeIt        = "doesn't send a completion notice"
        var completionNoticeCallCount = 0

        var gdriveUploadIt            = "doesn't upload a change report to the google drive"
        var gdriveFileCount           = 0

        var gdriveFile                = {}

        if (isCompletionNoticeExpected) {
          completionNoticeIt = "sends a completion notice with the new and old IP's"
          completionNoticeCallCount = 1

          gdriveUploadIt  = "uploads a change report to the google drive"
          gdriveFileCount = 1
        }

        it(gdriveUploadIt, function(done) {
          testGdriveReport({
            gdriveFolderId: gdriveFolderId,
            isUploadExpected: isCompletionNoticeExpected,
            gdriveFileObj: gdriveFile
	  },function (gdriveFile) {
            done()
	  })
        })


        it(completionNoticeIt, function () {
          testCompletionNotce({
            completionNoticeSpy: completionNoticeSpy,
            isCompletionNoticeExpected: isCompletionNoticeExpected,
            ips : {
              new: el.newIPStoreContents,
              old: (isStoreFilePresentAtStart)? el.oldIPStoreContents : {external: "-1", internal: "-1"}
	    },
            webViewLink: gdriveFile.webViewLink
	  })
	})


        /*
         * Test for an error message
         */

        var errorNoticeIt        = "doesn't send an error notice"
        var errorNoticeCallCount = 0
        if (isErrorNoticeExpected) {
          errorNoticeIt = "sends an error notice"
          errorNoticeCallCount = 1
        }

        it(errorNoticeIt, function () {
          errorNoticeSpy.callCount.should.equal(errorNoticeCallCount)
	})
      })
    })
  })
})





describe("Problems with the last_ip file", function () {

  this.timeout(timeout)


  var completionNoticeSpy = null
  var errorNoticeSpy      = null
  var restoreReporter     = null
  var gdriveFolderId      = null
  var gdriveFile          = {}
  var newIPStoreContents  = {}


  describe("when the last_ip file can't be opened", function () {


    before( function(done) {

      completionNoticeSpy = sinon.spy();
      errorNoticeSpy      = sinon.spy();

      var extIPServiceStub = stubExtIpService(null)
      var intIPServiceStub = stubIntIpService(null)

      restoreReporter = ipTracker.__set__('reporter', {
        configure: function () {},
        handleError: errorNoticeSpy,
        sendCompletionNotice: completionNoticeSpy
      })

      var restoreJsonFile = ipTracker.__set__('jsonFile.readFile', function (file, cb) {
        var err = new Error("Simulated failure")
        cb(err)
      })


      var completionJobs = [
        Q.nfcall(createTestGDriveFolder, null),
        Q.nfcall(createStubStoreFile,{external: genericOldExtIP, internal: genericOldIntIP})
      ]

      Q.all(completionJobs)
      .spread (function (gdriveFolder, empty) {
        gdriveFolderId = gdriveFolder.id
        return Q.nfcall(ipTracker,null)
      })
      .done(function () {
        restoreJsonFile()
        done()
      });

    })

    after( function (done) {
      restoreReporter()
      doCleanup({
        gdriveFolderId: gdriveFolderId
      },done)
    })

    /*
     * Test for the final value of the ip store file
     */

    it("creates a new IP store file with the known IPs", function(done) {
      jsonFile.readFile(cfg.ipStoreFile, function(err, ret) {
        if (err) throw new Error ('Error loading last_ip file: ' + err)
        newIPStoreContents = ret
        newIPStoreContents.external.should.equal(serviceStubExtIP)
        newIPStoreContents.internal.should.equal(serviceStubIntIP)
        done()
      })
    })

    /*
     * Test for a completion report upload to gdrive
     */

    it("uploads a change report to the google drive", function (done) {
      testGdriveReport({
        gdriveFolderId: gdriveFolderId,
        isUploadExpected: true,
        gdriveFileObj: gdriveFile
      },function (gdriveFile) {
        done()
      })
    })

    /*
     * Test for a completion notice
     */

    it("sends a completion notice with the new and old IP's", function () {
      testCompletionNotce({
        completionNoticeSpy: completionNoticeSpy,
        isCompletionNoticeExpected: true,
        ips : {
          new: newIPStoreContents,
          old: {external: "-1", internal: "-1"}
        },
        webViewLink: gdriveFile.webViewLink
      })
    })


    /*
     * Test for an error message
     */
    it("sends an error notice", function () {
      errorNoticeSpy.callCount.should.equal(1)
    })

  })



  describe("when the last_ip file can't be written to", function () {


    before( function(done) {

      completionNoticeSpy = sinon.spy();
      errorNoticeSpy      = sinon.spy();

      var extIPServiceStub = stubExtIpService(null)
      var intIPServiceStub = stubIntIpService(null)

      restoreReporter = ipTracker.__set__('reporter', {
        configure: function () {},
        handleError: errorNoticeSpy,
        sendCompletionNotice: completionNoticeSpy
      })



      var restoreJsonFile

      Q.all([
        Q.nfcall(createTestGDriveFolder, null),
        Q.nfcall(createStubStoreFile,{external: genericOldExtIP, internal: genericOldIntIP})
      ])
      .spread (function (gdriveFolder, empty) {

        gdriveFolderId = gdriveFolder.id

        restoreJsonFile = ipTracker.__set__('jsonFile.writeFile', function (file, contents, cb) {
          var err = new Error("Simulated failure")
          cb(err)
        })

        return Q.nfcall(ipTracker,null)
      })
      .done(function () {
        restoreJsonFile()
        done()
      });

    })

    after( function (done) {
      restoreReporter()
      doCleanup({
        gdriveFolderId: gdriveFolderId
      },done)
    })


    it("can't trash the old last_ip store file")

    it("trashes the old last_ip store file", function(done) {
      jsonFile.readFile(cfg.ipStoreFile, function(err, newIPStoreContents) {
        err.code.should.equal('ENOENT')
        done()
      })
    })

    /*
     * Test for a completion report upload to gdrive
     */

    it("uploads a change report to the google drive", function(done) {
      testGdriveReport({
        gdriveFolderId: gdriveFolderId,
        isUploadExpected: true,
        gdriveFileObj: gdriveFile
      },function (gdriveFile) {
        done()
      })
    })

    /*
     * Test for a completion notice
     */

    it("sends a completion notice with the new and old IP's", function () {
      testCompletionNotce({
        completionNoticeSpy: completionNoticeSpy,
        isCompletionNoticeExpected: true,
        ips : {
          new: {external: serviceStubExtIP, internal: serviceStubIntIP},
          old: {external: genericOldExtIP,  internal: genericOldIntIP}
        },
        webViewLink: gdriveFile.webViewLink
      })
    })

    /*
     * Test for an error message
     */
    it("sends an error notice", function () {
      errorNoticeSpy.callCount.should.equal(1)
    })


  })

})



describe("Problems with the google drive upload", function () {
    it("google drive can't be reached")
    it("parent folder can't be found")
    it("multiple parent folders found with the same name")
})
